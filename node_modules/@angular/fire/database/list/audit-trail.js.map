{"version":3,"file":"audit-trail.js","sourceRoot":"","sources":["../../../../src/database/list/audit-trail.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAE/C,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAGhD,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,gBAAgB,CAAC;AAEtE,MAAM,UAAU,UAAU,CAAI,KAAoB,EAAE,MAAqB;IACvE,IAAM,WAAW,GAAG,YAAY,CAAI,KAAK,EAAE,MAAM,CAAC;SAC/C,IAAI,CACH,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM,IAAK,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,EAAE,EAAE,CAAC,CACpD,CAAC;IACJ,OAAO,aAAa,CAAI,KAAK,EAAE,WAAW,CAAC,CAAC;AAC9C,CAAC;AAOD,SAAS,UAAU,CAAI,KAAoB;IAIzC,OAAO,OAAO,CAAI,KAAK,EAAE,OAAO,CAAC;SAChC,IAAI,CACH,GAAG,CAAC,UAAA,IAAI;QAEN,IAAI,aAAa,CAAC;QAElB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK;YACxB,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC;YAAC,OAAO,KAAK,CAAC;QAC1C,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE,IAAI,MAAA,EAAE,aAAa,eAAA,EAAE,CAAC;IACjC,CAAC,CAAC,CACH,CAAC;AACJ,CAAC;AAED,SAAS,aAAa,CAAI,KAAoB,EAAE,OAAwC;IACtF,IAAM,OAAO,GAAG,UAAU,CAAI,KAAK,CAAC,CAAC;IACrC,OAAO,OAAO;SACX,IAAI,CACH,cAAc,CAAC,OAAO,CAAC,EAGvB,GAAG,CAAC,UAAC,EAAiB;YAAhB,cAAM,EAAE,eAAO;QAEnB,IAAI,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAEzC,IAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,EAAR,CAAQ,CAAC,CAAC;QACjD,OAAO,EAAE,OAAO,SAAA,EAAE,aAAa,eAAA,EAAE,UAAU,YAAA,EAAE,CAAA;IAC/C,CAAC,CAAC,EAIF,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAlD,CAAkD,CAAC,EAGrE,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,OAAO,EAAZ,CAAY,CAAC,CAC1B,CAAC;AACN,CAAC","sourcesContent":["import { DataSnapshot, DatabaseQuery, ChildEvent, DatabaseSnapshot, AngularFireAction, SnapshotAction } from '../interfaces';\nimport { stateChanges } from './state-changes';\nimport { Observable } from 'rxjs';\nimport { fromRef } from '../observable/fromRef';\nimport { AngularFireDatabase } from '../database';\n\nimport { skipWhile, withLatestFrom, map, scan } from 'rxjs/operators';\n\nexport function auditTrail<T>(query: DatabaseQuery, events?: ChildEvent[]): Observable<SnapshotAction<T>[]> {\n  const auditTrail$ = stateChanges<T>(query, events)\n    .pipe(\n      scan((current, action) => [...current, action], [])\n    );\n  return waitForLoaded<T>(query, auditTrail$);\n}\n\ninterface LoadedMetadata {\n  data: AngularFireAction<DataSnapshot>;\n  lastKeyToLoad: any;\n}\n\nfunction loadedData<T>(query: DatabaseQuery): Observable<LoadedMetadata> {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef<T>(query, 'value')\n  .pipe(\n    map(data => {\n      // Store the last key in the data set\n      let lastKeyToLoad;\n      // Loop through loaded dataset to find the last key\n      data.payload.forEach(child => {\n        lastKeyToLoad = child.key; return false;\n      });\n      // return data set and the current last key loaded\n      return { data, lastKeyToLoad };\n    })\n  );\n}\n\nfunction waitForLoaded<T>(query: DatabaseQuery, action$: Observable<SnapshotAction<T>[]>) {\n  const loaded$ = loadedData<T>(query);\n  return loaded$\n    .pipe(\n      withLatestFrom(action$),\n      // Get the latest values from the \"loaded\" and \"child\" datasets\n      // We can use both datasets to form an array of the latest values.\n      map(([loaded, actions]) => {\n        // Store the last key in the data set\n        let lastKeyToLoad = loaded.lastKeyToLoad;\n        // Store all child keys loaded at this point\n        const loadedKeys = actions.map(snap => snap.key);\n        return { actions, lastKeyToLoad, loadedKeys }\n      }),\n      // This is the magical part, only emit when the last load key\n      // in the dataset has been loaded by a child event. At this point\n      // we can assume the dataset is \"whole\".\n      skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1),\n      // Pluck off the meta data because the user only cares\n      // to iterate through the snapshots\n      map(meta => meta.actions)\n    );\n}\n"]}