{"version":3,"file":"collection.js","sourceRoot":"","sources":["../../../../src/firestore/collection/collection.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, CollectionReference, Query, DocumentReference, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\nimport { runInZone } from '@angular/fire';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if(!events || events!.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param ref\n   */\n  constructor(\n    public readonly ref: CollectionReference,\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return this.afs.scheduler.keepUnstableUntilFirst(\n        this.afs.scheduler.runOutsideAngular(\n          docChanges<T>(this.query)\n        )\n      );\n    }\n    return this.afs.scheduler.keepUnstableUntilFirst(\n        this.afs.scheduler.runOutsideAngular(\n          docChanges<T>(this.query)\n        )\n      )\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0)\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const sortedChanges$ = sortedChanges<T>(this.query, validatedEvents);\n    const scheduledSortedChanges$ = this.afs.scheduler.runOutsideAngular(sortedChanges$);\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduledSortedChanges$);\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   * \n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   * @param options\n   */\n  valueChanges(): Observable<T[]>\n  valueChanges({}): Observable<T[]>\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    const fromCollectionRef$ = fromCollectionRef<T>(this.query);\n    const scheduled$ = this.afs.scheduler.runOutsideAngular(fromCollectionRef$);\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduled$)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return { \n              ...a.data() as Object, \n              ...{ [options.idField]: a.id } \n            } as T & { [T in K]: string };\n          } else {\n            return a.data()\n          }\n        }))\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once. \n   * @param options \n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      runInZone(this.afs.scheduler.zone)\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   * @param path\n   */\n  doc<T>(path?: string): AngularFirestoreDocument<T> {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\n  }\n}\n"]}